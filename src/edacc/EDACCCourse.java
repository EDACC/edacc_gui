/*
 * EDACCCourse.java
 *
 * Created on 03.08.2011, 22:36:43
 */
package edacc;

import edacc.experiment.InstanceTableModel;
import edacc.experiment.TableColumnSelector;
import edacc.model.Instance;
import edacc.model.InstanceSeed;
import java.awt.Cursor;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import javax.activation.ActivationDataFlavor;
import javax.activation.DataHandler;
import javax.swing.DropMode;
import javax.swing.JComponent;
import javax.swing.JTable;
import javax.swing.RowSorter;
import javax.swing.RowSorter.SortKey;
import javax.swing.TransferHandler;
import javax.swing.table.TableRowSorter;

/**
 *
 * @author simon
 */
public class EDACCCourse extends javax.swing.JDialog {

    private InstanceSeedTableModel model;
    private TableColumnSelector selector;
    private boolean cancelled;

    /** Creates new form EDACCCourse */
    public EDACCCourse(java.awt.Frame parent, boolean modal, List<InstanceSeed> list, final boolean editable) {
        super(parent, modal);
        model = new InstanceSeedTableModel(list, editable);
        initComponents();
        TableRowSorter<InstanceSeedTableModel> sorter = new TableRowSorter<InstanceSeedTableModel>(model) {

            {
                model.setSorter(this);
            }

            @Override
            public boolean isSortable(int column) {
                if (!editable) return true;
                return column != InstanceSeedTableModel.COL_ORDER;
            }
        };
        sorter.setSortsOnUpdates(false);
        tblInstanceSeed.setRowSorter(sorter);
        tblInstanceSeed.setModel(model);
        if (editable) {
            tblInstanceSeed.setDragEnabled(true);
            tblInstanceSeed.setDropMode(DropMode.INSERT_ROWS);
            tblInstanceSeed.setTransferHandler(new TableRowTransferHandler(tblInstanceSeed));
        } else {
            btnCancel.setVisible(false);
            btnGenerate.setText("Close");
        }
        tblInstanceSeed.removeColumn(tblInstanceSeed.getColumnModel().getColumn(tblInstanceSeed.convertColumnIndexToView(model.getBenchTypeColumnIndex())));
        tblInstanceSeed.removeColumn(tblInstanceSeed.getColumnModel().getColumn(tblInstanceSeed.convertColumnIndexToView(model.getSelectedColumnIndex())));

        selector = new TableColumnSelector(tblInstanceSeed);
        boolean[] v = selector.getColumnVisibility();
        for (int i = 3; i < v.length; i++) {
            v[i] = false;
        }
        selector.setColumnVisiblity(v);
        edacc.experiment.Util.updateTableColumnWidth(tblInstanceSeed);
        cancelled = true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tblInstanceSeed = new JTableTooltipInformation();
        btnGenerate = new javax.swing.JButton();
        btnColumns = new javax.swing.JButton();
        btnCancel = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(edacc.EDACCApp.class).getContext().getResourceMap(EDACCCourse.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setName("Form"); // NOI18N

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(resourceMap.getString("jPanel1.border.title"))); // NOI18N
        jPanel1.setName("jPanel1"); // NOI18N

        jScrollPane1.setName("jScrollPane1"); // NOI18N

        tblInstanceSeed.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        tblInstanceSeed.setName("tblInstanceSeed"); // NOI18N
        tblInstanceSeed.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane1.setViewportView(tblInstanceSeed);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 615, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 345, Short.MAX_VALUE)
        );

        btnGenerate.setText(resourceMap.getString("btnGenerate.text")); // NOI18N
        btnGenerate.setName("btnGenerate"); // NOI18N
        btnGenerate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerateActionPerformed(evt);
            }
        });

        btnColumns.setText(resourceMap.getString("btnColumns.text")); // NOI18N
        btnColumns.setName("btnColumns"); // NOI18N
        btnColumns.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnColumnsActionPerformed(evt);
            }
        });

        btnCancel.setText(resourceMap.getString("btnCancel.text")); // NOI18N
        btnCancel.setName("btnCancel"); // NOI18N
        btnCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(btnColumns)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 386, Short.MAX_VALUE)
                .addComponent(btnCancel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnGenerate)
                .addContainerGap())
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnGenerate)
                    .addComponent(btnColumns)
                    .addComponent(btnCancel))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnColumnsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnColumnsActionPerformed
        List<SortKey> sortKeys = (List<SortKey>) tblInstanceSeed.getRowSorter().getSortKeys();
        List<String> columnNames = new ArrayList<String>();
        for (SortKey sk : sortKeys) {
            columnNames.add(tblInstanceSeed.getColumnName(tblInstanceSeed.convertColumnIndexToView(sk.getColumn())));
        }
        EDACCInstanceColumnSelection dialog = new EDACCInstanceColumnSelection(EDACCApp.getApplication().getMainFrame(), true, selector, InstanceTableModel.COL_PROP + 1);
        dialog.setLocationRelativeTo(EDACCApp.getApplication().getMainFrame());
        dialog.setVisible(true);
        List<SortKey> newSortKeys = new ArrayList<SortKey>();
        for (int k = 0; k < columnNames.size(); k++) {
            String col = columnNames.get(k);
            for (int i = 0; i < tblInstanceSeed.getColumnCount(); i++) {
                if (tblInstanceSeed.getColumnName(i).equals(col)) {
                    newSortKeys.add(new SortKey(tblInstanceSeed.convertColumnIndexToModel(i), sortKeys.get(k).getSortOrder()));
                }
            }
        }
        tblInstanceSeed.getRowSorter().setSortKeys(newSortKeys);
        edacc.experiment.Util.updateTableColumnWidth(tblInstanceSeed);
    }//GEN-LAST:event_btnColumnsActionPerformed

    private void btnCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelActionPerformed
        cancelled = true;
        setVisible(false);
    }//GEN-LAST:event_btnCancelActionPerformed

    private void btnGenerateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerateActionPerformed
        cancelled = false;
        setVisible(false);
    }//GEN-LAST:event_btnGenerateActionPerformed

    public List<InstanceSeed> getInstanceSeedList() {
        LinkedList<InstanceSeed> res = new LinkedList<InstanceSeed>();
        for (int row = 0; row < tblInstanceSeed.getRowCount(); row++) {
            res.add(model.getInstanceSeedAt(tblInstanceSeed.convertRowIndexToModel(row)));
        }
        return res;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCancel;
    private javax.swing.JButton btnColumns;
    private javax.swing.JButton btnGenerate;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable tblInstanceSeed;
    // End of variables declaration//GEN-END:variables

    private class InstanceSeedTableModel extends InstanceTableModel implements Reorderable {

        private static final int COL_ORDER = 0;
        private static final int COL_SEED = 1;
        private TableRowSorter<InstanceSeedTableModel> sorter;
        private String[] columns = {"Order", "Seed"};
        private List<InstanceSeed> list;
        private ArrayList<Instance> instances;
        private boolean editable;

        public InstanceSeedTableModel(List<InstanceSeed> list, boolean editable) {
            super();
            this.editable = editable;
            instances = new ArrayList<Instance>();
            for (InstanceSeed is : list) {
                instances.add(is.instance);
            }
            super.setInstances(instances, false, true);
            this.list = list;
            fireTableDataChanged();
        }

        @Override
        public int getColumnCount() {
            return columns.length + super.getColumnCount();
        }

        @Override
        public String getColumnName(int column) {
            if (column < columns.length) {
                return columns[column];
            } else {
                return super.getColumnName(column - columns.length);
            }
        }

        @Override
        public int getRowCount() {
            return list == null ? 0 : list.size();
        }

        @Override
        public Object getValueAt(int row, int column) {
            if (column < columns.length) {
                switch (column) {
                    case COL_ORDER:
                        if (editable) {
                            return sorter.convertRowIndexToView(row);
                        } else {
                            return row;
                        }
                    case COL_SEED:
                        return list.get(row).seed;
                    default:
                        return "";
                }
            } else {
                return super.getValueAt(row, column - columns.length);
            }
        }

        @Override
        public boolean isCellEditable(int row, int column) {
            return false;
        }

        @Override
        public void reorder(int fromIndex, int toIndex) {
            InstanceSeed tmp = list.get(fromIndex);
            Instance tmpInstance = instances.get(fromIndex);
            list.remove(fromIndex);
            instances.remove(fromIndex);
            if (toIndex > fromIndex) {
                toIndex--;
            }
            list.add(toIndex, tmp);
            instances.add(toIndex, tmpInstance);
            this.fireTableRowsUpdated(Math.min(fromIndex, toIndex), Math.max(fromIndex, toIndex));
        }

        private void setSorter(TableRowSorter<InstanceSeedTableModel> aThis) {
            sorter = aThis;
        }

        private int getBenchTypeColumnIndex() {
            return columns.length + InstanceTableModel.COL_BENCHTYPE;
        }

        private int getSelectedColumnIndex() {
            return columns.length + InstanceTableModel.COL_SELECTED;
        }

        @Override
        public Class getColumnClass(int col) {
            switch (col) {
                case COL_ORDER:
                    return Integer.class;
                case COL_SEED:
                    return Integer.class;
                default:
                    return super.getColumnClass(col - columns.length);
            }
        }

        public InstanceSeed getInstanceSeedAt(int row) {
            return list.get(row);
        }

        @Override
        public void reorder(int[] order) {
            ArrayList<InstanceSeed> tmp = new ArrayList<InstanceSeed>();
            for (int i : order) {
                tmp.add(list.get(i));
            }
            list = tmp;
            fireTableDataChanged();
        }
    }

    private class TableRowTransferHandler extends TransferHandler {

        private final DataFlavor localObjectFlavor = new ActivationDataFlavor(Integer.class, DataFlavor.javaJVMLocalObjectMimeType, "Integer Row Index");
        private JTable table = null;

        public TableRowTransferHandler(JTable table) {
            this.table = table;
        }

        @Override
        protected Transferable createTransferable(JComponent c) {
            assert (c == table);
            return new DataHandler(new Integer(table.getSelectedRow()), localObjectFlavor.getMimeType());
        }

        @Override
        public boolean canImport(TransferHandler.TransferSupport info) {
            boolean b = info.getComponent() == table && info.isDrop() && info.isDataFlavorSupported(localObjectFlavor);
            return b;
        }

        @Override
        public int getSourceActions(JComponent c) {
            return TransferHandler.COPY_OR_MOVE;
        }

        @Override
        public boolean importData(TransferHandler.TransferSupport info) {
            JTable target = (JTable) info.getComponent();
            JTable.DropLocation dl = (JTable.DropLocation) info.getDropLocation();
            int index = dl.getRow();
            int max = table.getModel().getRowCount();
            if (index < 0 || index > max) {
                index = max;
            }
            try {
                Integer rowFrom = (Integer) info.getTransferable().getTransferData(localObjectFlavor);
                if (rowFrom != -1 && rowFrom != index) {
                    if (!table.getRowSorter().getSortKeys().isEmpty()) {
                        int[] order = new int[table.getRowCount()];
                        for (int i = 0; i < table.getRowCount(); i++)
                            order[i] = table.convertRowIndexToModel(i);
                        ((Reorderable) table.getModel()).reorder(order);
                        table.getRowSorter().setSortKeys(null);
                    }
                    ((Reorderable) table.getModel()).reorder(rowFrom, index);
                    if (index > rowFrom) {
                        index--;
                    }
                    target.getSelectionModel().addSelectionInterval(index, index);
                    return true;
                }
            } catch (Exception e) {
            }
            return false;
        }

        @Override
        protected void exportDone(JComponent c, Transferable t, int act) {
            if (act == TransferHandler.MOVE) {
                table.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
            }
        }
    }

    private interface Reorderable {
        
        public void reorder(int fromIndex, int toIndex);
        public void reorder(int[] order);
    }
}
